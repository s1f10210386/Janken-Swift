"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __importDefault(require("path"));
var createControllersText_1 = __importDefault(require("./createControllersText"));
var genHandlerText = function (isAsync) { return "\nconst ".concat(isAsync ? 'asyncM' : 'm', "ethodToHandler = (\n  methodCallback: ServerHandler").concat(isAsync ? 'Promise' : '', "<any, any>,\n): RouteHandlerMethod => ").concat(isAsync ? 'async ' : '', "(req, reply) => {\n  const data = ").concat(isAsync ? 'await ' : '', "methodCallback(req as any) as any;\n\n  if (data.headers !== undefined) reply.headers(data.headers);\n\n  reply.code(data.status).send(data.body);\n};\n"); };
exports.default = (function (input, project) {
    var _a = (0, createControllersText_1.default)("".concat(input, "/api"), project !== null && project !== void 0 ? project : input), imports = _a.imports, consts = _a.consts, controllers = _a.controllers;
    var hasNumberTypeQuery = controllers.includes('parseNumberTypeQueryParams(');
    var hasBooleanTypeQuery = controllers.includes('parseBooleanTypeQueryParams(');
    var hasOptionalQuery = controllers.includes(' callParserIfExistsQuery(');
    var hasTypedParams = controllers.includes(' createTypedParamsHandler(');
    var hasMultipart = controllers.includes(' formatMultipartData(');
    var hasMethodToHandler = controllers.includes(' methodToHandler(');
    var hasAsyncMethodToHandler = controllers.includes(' asyncMethodToHandler(');
    var hasRouteShorthandOptions = controllers.includes(' as RouteShorthandOptions,');
    var hasValidatorCompiler = controllers.includes(' validatorCompiler');
    var hasValidatorsToSchema = controllers.includes('validatorsToSchema(');
    var headImports = [];
    if (hasMultipart) {
        headImports.push("import multipart from '@fastify/multipart';");
    }
    headImports.push("import type { FastifyMultipartAttachFieldsToBodyOptions, ".concat(hasMultipart ? 'Multipart, ' : '', "MultipartFile } from '@fastify/multipart';"));
    headImports.push("import type { ReadStream } from 'fs';", "import type { HttpStatusOk, AspidaMethodParams } from 'aspida';");
    return {
        text: "".concat(headImports.join('\n'), "\nimport type { Schema } from 'fast-json-stringify';\nimport type { z } from 'zod';\n").concat(imports, "import type { FastifyInstance, RouteHandlerMethod, preValidationHookHandler").concat(hasValidatorCompiler ? ', FastifySchema, FastifySchemaCompiler' : '').concat(hasRouteShorthandOptions ? ', RouteShorthandOptions' : '', ", onRequestHookHandler, preParsingHookHandler, preHandlerHookHandler } from 'fastify';\n\nexport type FrourioOptions = {\n  basePath?: string;\n  multipart?: FastifyMultipartAttachFieldsToBodyOptions;\n};\n\ntype HttpStatusNoOk = 301 | 302 | 400 | 401 | 402 | 403 | 404 | 405 | 406 | 409 | 500 | 501 | 502 | 503 | 504 | 505;\n\ntype PartiallyPartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\ntype BaseResponse<T, U, V> = {\n  status: V extends number ? V : HttpStatusOk;\n  body: T;\n  headers: U;\n};\n\ntype ServerResponse<K extends AspidaMethodParams> =\n  | (K extends { resBody: K['resBody']; resHeaders: K['resHeaders'] }\n  ? BaseResponse<K['resBody'], K['resHeaders'], K['status']>\n  : K extends { resBody: K['resBody'] }\n  ? PartiallyPartial<BaseResponse<K['resBody'], K['resHeaders'], K['status']>, 'headers'>\n  : K extends { resHeaders: K['resHeaders'] }\n  ? PartiallyPartial<BaseResponse<K['resBody'], K['resHeaders'], K['status']>, 'body'>\n  : PartiallyPartial<\n      BaseResponse<K['resBody'], K['resHeaders'], K['status']>,\n      'body' | 'headers'\n    >)\n  | PartiallyPartial<BaseResponse<any, any, HttpStatusNoOk>, 'body' | 'headers'>;\n\nexport type MultipartFileToBlob<T extends Record<string, unknown>> = {\n  [P in keyof T]: Required<T>[P] extends MultipartFile\n    ? Blob | ReadStream\n    : Required<T>[P] extends MultipartFile[]\n    ? (Blob | ReadStream)[]\n    : T[P];\n};\n\ntype BlobToFile<T extends AspidaMethodParams> = T['reqFormat'] extends FormData\n  ? {\n      [P in keyof T['reqBody']]: Required<T['reqBody']>[P] extends Blob | ReadStream\n        ? MultipartFile\n        : Required<T['reqBody']>[P] extends (Blob | ReadStream)[]\n        ? MultipartFile[]\n        : T['reqBody'][P];\n    }\n  : T['reqBody'];\n\ntype RequestParams<T extends AspidaMethodParams> = Pick<{\n  query: T['query'];\n  body: BlobToFile<T>;\n  headers: T['reqHeaders'];\n}, {\n  query: Required<T>['query'] extends {} | null ? 'query' : never;\n  body: Required<T>['reqBody'] extends {} | null ? 'body' : never;\n  headers: Required<T>['reqHeaders'] extends {} | null ? 'headers' : never;\n}['query' | 'body' | 'headers']>;\n\ntype ServerHandler<T extends AspidaMethodParams, U extends Record<string, unknown> = {}> = (\n  req: RequestParams<T> & U,\n) => ServerResponse<T>;\n\ntype ServerHandlerPromise<T extends AspidaMethodParams, U extends Record<string, unknown> = {}> = (\n  req: RequestParams<T> & U,\n) => Promise<ServerResponse<T>>;\n\ntype AddedHandler<T, R extends Record<string, unknown>> = T extends (req: infer U, ...args: infer V) => infer W ? (req: U & Partial<R>, ...args: V) => W : never;\n\nexport type ServerHooks<R extends Record<string, unknown> = {}> = {\n  onRequest?: AddedHandler<onRequestHookHandler, R> | AddedHandler<onRequestHookHandler, R>[];\n  preParsing?: AddedHandler<preParsingHookHandler, R> | AddedHandler<preParsingHookHandler, R>[];\n  preValidation?: AddedHandler<preValidationHookHandler, R> | AddedHandler<preValidationHookHandler, R>[];\n  preHandler?: AddedHandler<preHandlerHookHandler, R> | AddedHandler<preHandlerHookHandler, R>[];\n};\n\nexport type ServerMethodHandler<T extends AspidaMethodParams,  U extends Record<string, unknown> = {}> = ServerHandler<T, U> | ServerHandlerPromise<T, U> | {\n  validators?: { [Key in keyof RequestParams<T>]?: z.ZodType<RequestParams<T>[Key]>};\n  schemas?: { response?: { [V in HttpStatusOk]?: Schema }};\n  hooks?: ServerHooks<U>;\n  handler: ServerHandler<T, U> | ServerHandlerPromise<T, U>;\n};\n").concat(hasNumberTypeQuery
            ? "\nconst parseNumberTypeQueryParams = (numberTypeParams: [string, boolean, boolean][]): preValidationHookHandler => (req, reply, done) => {\n  const query: any = req.query;\n\n  for (const [key, isOptional, isArray] of numberTypeParams) {\n    const param = isArray ? (query[`${key}[]`] ?? query[key]) : query[key];\n\n    if (isArray) {\n      if (!isOptional && param === undefined) {\n        query[key] = [];\n      } else if (!isOptional || param !== undefined) {\n        const vals = (Array.isArray(param) ? param : [param]).map(Number);\n\n        if (vals.some(isNaN)) {\n          reply.code(400).send();\n          return;\n        }\n\n        query[key] = vals as any;\n      }\n\n      delete query[`${key}[]`];\n    } else if (!isOptional || param !== undefined) {\n      const val = Number(param);\n\n      if (isNaN(val)) {\n        reply.code(400).send();\n        return;\n      }\n\n      query[key] = val as any;\n    }\n  }\n\n  done();\n};\n"
            : '').concat(hasBooleanTypeQuery
            ? "\nconst parseBooleanTypeQueryParams = (booleanTypeParams: [string, boolean, boolean][]): preValidationHookHandler => (req, reply, done) => {\n  const query: any = req.query;\n\n  for (const [key, isOptional, isArray] of booleanTypeParams) {\n    const param = isArray ? (query[`${key}[]`] ?? query[key]) : query[key];\n\n    if (isArray) {\n      if (!isOptional && param === undefined) {\n        query[key] = [];\n      } else if (!isOptional || param !== undefined) {\n        const vals = (Array.isArray(param) ? param : [param]).map(p => p === 'true' ? true : p === 'false' ? false : null);\n\n        if (vals.some(v => v === null)) {\n          reply.code(400).send();\n          return;\n        }\n\n        query[key] = vals as any;\n      }\n\n      delete query[`${key}[]`];\n    } else if (!isOptional || param !== undefined) {\n      const val = param === 'true' ? true : param === 'false' ? false : null;\n\n      if (val === null) {\n        reply.code(400).send();\n        return;\n      }\n\n      query[key] = val as any;\n    }\n  }\n\n  done();\n};\n"
            : '').concat(hasOptionalQuery
            ? "\nconst callParserIfExistsQuery = (parser: OmitThisParameter<preValidationHookHandler>): preValidationHookHandler => (req, reply, done) =>\n  Object.keys(req.query as any).length ? parser(req, reply, done) : done();\n"
            : '').concat(hasTypedParams
            ? "\nconst createTypedParamsHandler = (numberTypeParams: string[]): preValidationHookHandler => (req, reply, done) => {\n  const params = req.params as Record<string, string | number>;\n\n  for (const key of numberTypeParams) {\n    const val = Number(params[key]);\n\n    if (isNaN(val)) {\n      reply.code(400).send();\n      return;\n    }\n\n    params[key] = val;\n  }\n\n  done();\n};\n"
            : '').concat(hasMultipart
            ? "\nconst formatMultipartData = (arrayTypeKeys: [string, boolean][]): preValidationHookHandler => (req, _, done) => {\n  const body: any = req.body;\n\n  for (const [key] of arrayTypeKeys) {\n    if (body[key] === undefined) body[key] = [];\n    else if (!Array.isArray(body[key])) {\n      body[key] = [body[key]];\n    }\n  }\n\n  Object.entries(body).forEach(([key, val]) => {\n    if (Array.isArray(val)) {\n      body[key] = (val as Multipart[]).map(v => 'file' in v ? v : (v as any).value);\n    } else {\n      body[key] = 'file' in (val as Multipart) ? val : (val as any).value;\n    }\n  });\n\n  for (const [key, isOptional] of arrayTypeKeys) {\n    if (!body[key].length && isOptional) delete body[key];\n  }\n\n  done();\n};\n"
            : '').concat(hasValidatorCompiler
            ? "\nconst validatorCompiler: FastifySchemaCompiler<FastifySchema> = ({ schema }) => (data: unknown) => {\n  const result = (schema as z.ZodType<unknown>).safeParse(data);\n  return result.success ? { value: result.data } : { error: result.error };\n};".concat(hasValidatorsToSchema
                ? "\n\nconst validatorsToSchema = ({ query, ...validators }: { query?: unknown; body?: unknown; headers?: unknown }): FastifySchema => ({\n  ...(query !== undefined ? { querystring: query } : {}),\n  ...validators,\n});"
                : '', "\n")
            : '').concat(hasMethodToHandler ? genHandlerText(false) : '').concat(hasAsyncMethodToHandler ? genHandlerText(true) : '', "\nexport default (fastify: FastifyInstance, options: FrourioOptions = {}) => {\n  const basePath = options.basePath ?? '';\n").concat(consts, "\n").concat(hasMultipart
            ? '  fastify.register(multipart, { attachFieldsToBody: true, limits: { fileSize: 1024 ** 3 }, ...options.multipart });\n\n'
            : '').concat(controllers, "\n  return fastify;\n};\n"),
        filePath: path_1.default.posix.join(input, '$server.ts'),
    };
});
//# sourceMappingURL=buildServerFile.js.map