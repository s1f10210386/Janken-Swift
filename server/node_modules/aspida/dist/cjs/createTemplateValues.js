"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const createDocComment_1 = __importDefault(require("./createDocComment"));
const createHash_1 = require("./createHash");
const createMethodsString_1 = __importDefault(require("./createMethodsString"));
const valNameRegExpStr = '^_[a-zA-Z][a-zA-Z0-9_]*';
const valNameRegExp = new RegExp(valNameRegExpStr);
const valTypeRegExpStr = '(@number|@string)';
const valTypeRegExp = new RegExp(valTypeRegExpStr);
const toJSValidString = (text) => text.replace(/[^a-zA-Z0-9$_]/g, '_').replace(/^(\d)/, '$$$1');
exports.default = (direntTree, basePath, trailingSlash, outputMode) => {
    const imports = [];
    const pathes = [];
    const getMethodsString = (filepath, methods, indent, newPrefix, newUrl) => {
        const path = filepath.replace(/'/g, "\\'");
        const importName = `Methods_${(0, createHash_1.createHash)(path)}`;
        imports.push(`import type { Methods as ${importName} } from '${path}';`);
        let newPath = `'${decodeURIComponent(newUrl)}${trailingSlash ? '/' : ''}'`;
        if (newPath.length > 2) {
            if (!pathes.includes(newPath))
                pathes.push(newPath);
            newPath = `PATH${pathes.indexOf(newPath)}`;
        }
        return (0, createMethodsString_1.default)(methods, indent, importName, newPrefix && newPath.length > 2 ? `\`\${${newPrefix}}\${${newPath}}\`` : newPrefix || newPath, outputMode);
    };
    const createApiString = (tree, importBasePath, indent, dirDeps, prefix, url, text, methodsOfIndexTsFile) => {
        const props = tree.children
            .map(dirent => {
            var _a;
            const filename = dirent.name;
            const basename = dirent.isDir ? filename : filename.replace(/\.ts$/, '');
            const hasVal = filename.startsWith('_');
            let valFn = `${indent}${toJSValidString(decodeURIComponent(basename))}: {\n<% next %>\n${indent}}`;
            let newPrefix = prefix;
            let newUrl = `${url}/${basename}`;
            if (hasVal) {
                const valPathRegExp = new RegExp(`${valNameRegExpStr}${valTypeRegExpStr}?((\\.|%[0-9a-fA-F]{2})[a-zA-Z0-9]+)?$`);
                if (!valPathRegExp.test(basename)) {
                    throw new Error(`aspida \u001b[43m\u001b[31mERROR\u001b[0m '${basename}' does not match '${valPathRegExp.toString()}'.`);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const valName = basename.match(valNameRegExp)[0];
                const valType = basename.replace(valName, '').startsWith('@')
                    ? basename.split('@')[1].slice(0, 6)
                    : null;
                const postfix = decodeURIComponent(basename.replace(valName, '').replace(valType ? `@${valType}` : '', ''));
                const prevUrl = `'${decodeURIComponent(url)}${trailingSlash ? '/' : ''}'`;
                if (url.length && !pathes.includes(prevUrl))
                    pathes.push(prevUrl);
                const duplicatedNames = tree.children.filter(d => d.name.startsWith(valName));
                const prefixVal = `\`${prefix ? `\${${prefix}}` : ''}${url.length ? `\${PATH${pathes.indexOf(prevUrl)}}` : ''}${url.length && trailingSlash ? '' : '/'}\${val${dirDeps}}${postfix}\``;
                newPrefix = `prefix${dirDeps}`;
                newUrl = '';
                valFn = `${indent}${toJSValidString(valName)}${duplicatedNames.length > 1 && valType ? `_${valType}` : ''}${toJSValidString(postfix)}: (val${dirDeps}: ${valType !== null && valType !== void 0 ? valType : 'number | string'}) => {\n${indent}  const ${newPrefix} = ${prefixVal};\n\n${indent}  return {\n<% next %>\n${indent}  };\n${indent}}`;
            }
            const fallbackSpecialCharsProp = (text) => /%[0-9a-fA-F]{2}/.test(basename)
                ? `${text},\n${text.replace(/^( +?)[^ ]+?:/, `$1/**\n$1 * @deprecated \`${toJSValidString(basename.replace(valTypeRegExp, ''))}\` has been deprecated.\n$1 * Use \`${toJSValidString(decodeURIComponent(basename.replace(valTypeRegExp, '')))}\` instead\n$1 */\n$1${toJSValidString(basename.replace(valTypeRegExp, ''))}:`)}`
                : text;
            if (dirent.isDir) {
                const methodsOfIndexTsFile = (_a = tree.children.find(c => c.name === `${filename}.ts`)) !== null && _a !== void 0 ? _a : dirent.tree.children.find(c => c.name === 'index.ts');
                return fallbackSpecialCharsProp(createApiString(dirent.tree, `${importBasePath}/${filename}`, `${indent}${hasVal ? '  ' : ''}  `, dirDeps + 1, newPrefix, newUrl, `${(0, createDocComment_1.default)(indent, methodsOfIndexTsFile === null || methodsOfIndexTsFile === void 0 ? void 0 : methodsOfIndexTsFile.doc)}${valFn.replace('<% next %>', '<% props %>')}`, (methodsOfIndexTsFile === null || methodsOfIndexTsFile === void 0 ? void 0 : methodsOfIndexTsFile.isDir) === false
                    ? getMethodsString(`${importBasePath}/${filename}`, methodsOfIndexTsFile.methods, `${indent}${hasVal ? '  ' : ''}`, newPrefix, newUrl)
                    : undefined));
            }
            else if (filename !== 'index.ts' && tree.children.every(d => d.name !== basename)) {
                return fallbackSpecialCharsProp(`${(0, createDocComment_1.default)(indent, dirent.doc)}${valFn.replace('<% next %>', getMethodsString(`${importBasePath}/${basename}`, dirent.methods, `${indent}${hasVal ? '  ' : ''}`, newPrefix, newUrl))}`);
            }
            return null;
        })
            .filter((p) => !!p);
        return text.replace('<% props %>', `${props.join(',\n')}${methodsOfIndexTsFile
            ? `${props.length ? ',\n' : ''}${methodsOfIndexTsFile}`
            : props.length
                ? ','
                : ''}`);
    };
    const emptyMethodsRegExp = /.+{\n\n? +},?\n/;
    const rootIndexData = direntTree.children.find(c => c.name === 'index.ts');
    /* eslint-disable no-template-curly-in-string */
    let api = createApiString(direntTree, '.', '    ', 0, '', basePath, `{\n<% props %>\n  }`, rootIndexData && !rootIndexData.isDir
        ? getMethodsString('.', rootIndexData.methods, '  ', '', basePath)
        : undefined);
    while (emptyMethodsRegExp.test(api)) {
        api = api.replace(emptyMethodsRegExp, '');
    }
    return { api, imports, pathes };
};
//# sourceMappingURL=createTemplateValues.js.map